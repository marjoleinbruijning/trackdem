##' Create image sequence
##'
##' \code{createImageSeq} is a function to create an image sequence (.png) using 
##' videos file as input. All movies within a directory 'Movies' will
##' be exported. A directory 'ImageSequences' must exist in path. For each
##' movie, a new directory is created containing the recorded date and 
##' name of the movie.
##' @param path Path path to location of directory containing directories
##' 'Movies' and 'ImageSequences'.
##' @param x Number of pixels in horizontal direction (ncol); default is 1915.
##' @param y Number of pixels in vertical direction (nrow); default is 1080.
##' @param fps Frames per second, default is 15.
##' @param nsec Duration of movie that is exported, default is 2 seconds.
##' The middle nsec seconds of the movie are used.
##' @param ext The extension of the video, in lower case. Default is 'mts'.
##' @examples
##' \dontrun{
##' createImageSeq(path='~/Data/',ext='mp4')
##'	}
##' @author Caspar A. Hallmann, Marjolein Bruijning & Marco D. Visser
##' @export
simulate.trajectories<- function(nframes=20,nIndividuals=10,sampler=c("rnorm","runif"),
h=.05,rho=0,domain=c("square","circle"),correct.boundary=TRUE,sizes=runif(nIndividuals)*.012+.01,...){

# nframes			number of time frames(steps)
# nIndividuals		number of individual trajectories
# sampler			one of uniform or random for marginal (in x or y direction) displacement
# h					In case 'sampler' is "runif", then displacement in each direction lies within {-h,h} 
#					In case 'sampler' is "rnorm", then h is the standard deviation in each direction
# rho				correlation parameter for angle of displacement
# domain			one of "square" or "circle", imposing a [0-1,0-1] rectangle domain, or a circlular domain of radius 1, respectively.
# correct boundary 	ensure individual trajectories do not cross the domain boundaries 

sample.polar<-function(n=10,h=.05,rho=0,init=NULL){
	RHO<- matrix(rho,n,n)
	diag(RHO)<-1
	corPhiNorm<- MASS:::mvrnorm(1,rep(0,n),RHO)
	corPhiUnif<- pnorm(corPhiNorm)*2*pi
	r<- replicate(n,sqrt(sum(rnorm(2,0,h)^2)))
	steps<- cbind(r*cos(corPhiUnif),r*sin(corPhiUnif))
	if(is.null(init)){init<- runif(2,0,1)}
	RES <- array(,c(n,4))
	RES[1,1:2]<-init
	for(i in 1:(n-1)){
	RES[i+1,1:2]<- RES[i,1:2]+steps[i,1:2]
	}
	RES[,3]<-r
	RES[,4]<-corPhiUnif
	RES[n,3:4]<-NA
	RES
}


sampler=get(sampler[1])
domain=domain[1]

res<-do.call(rbind,

lapply(1:nIndividuals,function(j){
	# xy<-array(,c(nframes,2))
	# xy[1,]<-runif(2)
	# for(i in 2:nframes){
	# xy[i,]<- xy[i-1,] + sampler(2,0,h)
	init=NULL
	if( domain=="square") {init<-  runif(2,0,1) }
	if( domain=="circle") {phi<-runif(1,0,2*pi); r=runif(1,0,1) ;init<-  r*c(cos(phi),sin(phi))     }
	xy<- sample.polar(nframes,h,rho,init)
	if(correct.boundary&domain=="square"){
	for(i in 2:nframes){
	if(any(xy[i,1:2]>1)|any(xy[i,1:2]<0)){	# This ensures they stay in the square 0-1 x 0-1 domain
		cond=TRUE
		while(cond){
		news<-sample.polar(2,h,rho)
		xy[i,1:2]<- xy[i-1,1:2] + (news[2,1:2]-news[1,1:2])
		xy[i,3:4]<- news[1,3:4]
		cond<-FALSE
		if(any(xy[i,1:2]>1)|any(xy[i,1:2]<0)){ cond=TRUE}
		}
	}
	}
	}	
	if(correct.boundary&domain=="circle"){
	for(i in 2:nframes){
	#... should be replaced with all 
	if(sqrt(sum(xy[i,1:2]^2))>1){	# This ensures they stay in the circle with radius 1 domain
		cond=TRUE
		while(cond){
		news<-sample.polar(2,h,rho)
		xy[i,]<- xy[i-1,1:2] + (news[2,1:2]-news[1,1:2])
		xy[i,3:4]<- news[1,3:4]
		cond<-FALSE
		if(sqrt(sum(xy[i,1:2]^2))>1){ cond=TRUE}
		}
	}
	}
	}

	if(correct.boundary&!domain%in%c("square","circle")) stop("domain not recognized")
	cbind(id=j,frame=1:nframes,xy)
}))
colnames(res)<-c("id","t","x","y","r","phi")
res<-as.data.frame(res)
res$size=sizes[res$id]
attr(res,"domain")<-domain
return(res)
}


plot.trajectories<-function(traj,noise=FALSE,axes=FALSE,...){
lim<- ifelse(attr(traj,"domain")=="circle",-1,0)

plot(0,type="n",xlim=c(lim,1),ylim=c(lim,1),xlab="",ylab="",asp=1,axes=axes,frame=attr(traj,"domain")=="square")
if(noise){
generate.background(...,domain=attr(traj,"domain"))
}
if(lim==-1){
lines(cos(seq(0,2*pi,l=300)),sin(seq(0,2*pi,l=300)),lty=3)
}
tapply(1:nrow(traj),traj$id,function(i){
	lines(traj[i,c("x","y")],col=sample(colors()[-1],1))
})
invisible(NULL)
}

add.organisms<- function(traj,col="red"){
	n.orgs<- max(traj$id)
	tapply(1:nrow(traj),traj$id,function(i){
	ii<- which.max(traj[i,"t"])
	polygon(
	org(phi=-mean(traj[i[-ii],"phi"]),x=traj[i[ii],"x"],y=traj[i[ii],"y"],size=traj[i[1],"size"])
	,col=col,border=NA)
})
}

# makes an organism
org<-function(length=30,size=.05,phi=0,x=0,y=0){
piseq<-seq(0,2*pi,l=length)
fac<-c(seq(.1,1,l=length/2),seq(1,.1,l=length/2))
xyO<-cbind(cos(piseq),fac*sin(piseq))*size
xy0<-xyO%*%matrix(c(cos(phi),sin(phi),-sin(phi),cos(phi)),nc=2)
xy0[,1]<-xy0[,1]+x
xy0[,2]<-xy0[,2]+y
xy0

}
#

save.trajectory<-function(traj,noise=FALSE,add.noise=FALSE,name="trajectory",
                 axes=FALSE,background,pars=list(duration=10,density=10),...){

	z=max(traj$t)
	lim<- ifelse(attr(traj,"domain")=="circle",-1,0)

	if(noise){ 
	xx <- background$blured.x
	}
	
	if(add.noise){
        noisep<-add.noise.bg(bg=background,density=pars$density,duration=pars$duration)
	loc<-noisep[[2]]
	part<-noisep[[1]]
		}

	for(i in 1:z){

		Name=paste(name,formatC(i,width=nchar(z),flag="0"),sep="_")
		png(paste(Name,".png",sep=""))

		plot(0,type="n",xlim=c(lim,1),ylim=c(lim,1),xlab="",ylab="",asp=1,axes=axes)
		if(noise){
		image(xx,xx,background$blured,add=TRUE,col=colorRampPalette(c("transparent","grey"),alpha=TRUE)(64))}
		## add static noise		
		#if(noise){generate.background(...,domain=attr(traj,"domain"))}
		## add dynamic noise	
		if(add.noise&noise){
          	for(mb in 1:nrow(noisep[[1]])){
		      if (!is.na(loc[mb,i,2])) {
		        points(loc[mb,i,2],loc[mb,i,1],pch=16,cex=part$size[mb],col=part$color[mb])
		    }
		#text(x=loc[mb,i,2],y=loc[mb,i,1],labels=mb,cex=2)		
		}	
		
		if(lim==-1){
		lines(cos(seq(0,2*pi,l=300)),sin(seq(0,2*pi,l=300)),lty=3)
		}
		ii<-which(traj$t==i)
		for(j in ii){
		polygon(
		org(30,traj[j,"size"],phi=ifelse(is.na(traj[j,"phi"]),tapply(traj$phi,traj$id,mean,na.rm=T)[j==ii],traj[j,"phi"]),x=traj[j,"x"],y=traj[j,"y"])
		,col="red",border=NA)
		}

		}
		dev.off()
	}


} 


## generates background, or therwise plots an already generated background
generate.background<- function(background=NULL,spots.density=10,clustering=0,
                               blur=TRUE,blur.coef=.025,domain=c("square","circle"),
                               plot=TRUE,sizes=runif(spots.density,.1,1.5)){

# background
# spots.density
# clustering
# blur
# blur.coef
# domain
# plot

	domain=domain[1]
	if(domain=="circle") { lim=-1; area=2*pi; offset=0 }
	if(domain=="square") { lim=0; area=1; offset=.5 }

if(is.null(background)){

	# if(gradient.density){
		# parsd<-structure(runif(gradient.complexity+3),names=letters[1:(gradient.complexity+3)])
		# x=y=seq(lim,1,l=reso)
		# EG<-expand.grid(x=x,y=y)
		# X<-with(EG,cbind(1,x,y,x*y,x^2,y^2,x^2*y^2,x^3,y^3,x^3*x^4))
		# xt<- xtabs(I(X[,1:length(parsd)]%*%parsd)~x+y,EG)
		# class(xt)<-"matrix"
		# if(domain=="circle"){
			# xt[with(EG,sqrt(x^2+y^2)>1)]<-NA
		# }
		# image(x,y,xt,add=TRUE,col=grey.colors(132)[-(1:64)])
	# }

	if(spots.density>0){
	n<-round(spots.density)
	if(clustering!=0){stop("Clustering not implemented yet")} else {
	xysp<-matrix(runif(2*n,lim,1),ncol=2)
	if(domain=="circle"){
		cond=any(toofar<-sqrt(xysp[,1]^2+xysp[,2]^2)>1)
		while(cond){
		xysp[toofar,]<- runif(sum(toofar)*2,lim,1)
		cond=any(toofar<-sqrt(xysp[,1]^2+xysp[,2]^2)>1)
		}	
	}
	if(is.null(sizes)) sizes<-runif(n,.1,1.5)
	if(!blur&plot){ points(xysp,pch=19,cex=sizes) }
	}

	if(blur){
	xx<-seq(lim,1,l=512)
	xtsp<-xtabs(sizes~cut(xysp[,1],c(xx[1]-diff(xx[1:2]),xx))+cut(xysp[,2],c(xx[1]-diff(xx[1:2]),xx)))
	ffk<- outer(xx,xx,function(x,y){ dnorm(x,offset,blur.coef)*dnorm(y,offset,blur.coef) } )*diff(xx[1:2])^2
	blured<- Re(fft(fft(ffk)*fft(xtsp),i=T))/length(xtsp)
	blured<-blured[c(257:512,1:256),c(257:512,1:256)]
	#blured[blured<mean(blured)]<-NA
	if(plot){ image(xx,xx,blured,add=TRUE,col=colorRampPalette(c("transparent","grey"),alpha=TRUE)(64))}
	}
	}
} else {
	if(is.null(background$blured)){ points(background$xyspots,pch=19,cex=background$sizes) } else {
		image(background$blured.x,background$blured.x,background$blured,add=TRUE,col=colorRampPalette(c("transparent","grey"),alpha=TRUE)(64))
	}
	xysp<-background$xyspots
	blured<- background$blured
	xx<- background$blured.x
}


ret=list(xyspots=xysp,sizes=sizes)
if(blur){
	ret$blured<-blured
	ret$blured.x<-xx
}


invisible(ret)

}

## make a background sequence of nframe
## param(nframe) number of frames
## param(density) number of noise particles
## param(size) max size of noise in pixels
## param(duration) max number of frame noise is visible before regeneration
## param(bg) = previously generated background 
## param(speed) = max speed noise
## param(col.range) = color intensity range of noise
add.noise.bg=function(nframe=30,density=40,size=1,duration=10,speed=10,bg,
col.range=c(0,1)){

dims <- dim(bg$blured)
particles <- data.frame(size=runif(density,0,size),
			duration=sample(1:duration,density,replace=TRUE),
			color=rgb(runif(density,0,0),
				  runif(density,col.range[1],col.range[2]),
				  runif(density,col.range[1],col.range[2]),
					alpha=runif(density,col.range[1],col.range[2])),
			x=sample(1:dims[2],density,replace=TRUE),
                        y=sample(1:dims[1],density,replace=TRUE))  

particles$color <- as.character(particles$color)
locations<-array(dim=c(density,nframe,2))
locations[,1,1]<-particles$x
locations[,1,2]<-particles$y

sapply(2:(ncol(locations)), function(X) {
 	locations[,X,1]<<-(locations[,X-1,1]+sample((-speed):speed,density,replace=TRUE))
	locations[,X,2]<<-(locations[,X-1,2]+sample((-speed):speed,density,replace=TRUE))
	})

locations[,,1]<-locations[,,1]/dims[1]
locations[,,2]<-locations[,,2]/dims[2]

	for(i in 1:density){
	locations[i,sample(1:nframe,ceiling((duration/nframe)*nframe)),]<-NA
	
	}

return(list(particles,locations))
}

